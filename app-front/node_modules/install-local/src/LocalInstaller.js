"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const _ = __importStar(require("lodash"));
const child_process_1 = require("mz/child_process");
const fs_1 = __importDefault(require("mz/fs"));
const path_1 = __importDefault(require("path"));
const helpers_1 = require("./helpers");
const utils_1 = require("./utils");
const TEN_MEGA_BYTE = 1024 * 1024 * 10;
function quotify(value) {
    return `"${value}"`;
}
class LocalInstaller extends events_1.EventEmitter {
    constructor(sourcesByTarget, options) {
        super();
        this.sourcesByTarget = resolve(sourcesByTarget);
        this.options = Object.assign({}, options);
        this.uniqueDir = utils_1.getRandomTmpDir('node-local-install-');
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    async install() {
        await this.createTmpDirectory(this.uniqueDir);
        const packages = await this.resolvePackages();
        const installTargets = this.identifyInstallTargets(packages);
        await this.packAll();
        await this.installAll(installTargets);
        await this.removeTmpDirectory();
        return installTargets;
    }
    async createTmpDirectory(tmpDir) {
        return fs_1.default.mkdir(tmpDir);
    }
    installAll(installTargets) {
        this.emit('install_start', this.sourcesByTarget);
        return Promise.all(installTargets.map(target => this.installOne(target)))
            .then(() => void this.emit('install_end'));
    }
    installOne(target) {
        const toInstall = target.sources
            .map(source => resolvePackFile(this.uniqueDir, source.packageJson))
            .map(quotify)
            .join(' ');
        const options = {
            cwd: target.directory,
            maxBuffer: TEN_MEGA_BYTE
        };
        if (this.options.npmEnv) {
            options.env = this.options.npmEnv;
        }
        return child_process_1.exec(`npm i --no-save ${toInstall}`, options).then(([stdout, stderr]) => void this.emit('installed', target.packageJson.name, stdout.toString(), stderr.toString()));
    }
    resolvePackages() {
        const uniqueDirectories = _.uniq(Object.keys(this.sourcesByTarget)
            .concat(_.flatMap(Object.keys(this.sourcesByTarget), target => this.sourcesByTarget[target])));
        const allPackages = Promise.all(uniqueDirectories.map(directory => helpers_1.readPackageJson(directory).then(packageJson => ({ directory, packageJson }))));
        return allPackages.then(packages => {
            const packageByDirectory = {};
            packages.forEach(pkg => packageByDirectory[pkg.directory] = pkg.packageJson);
            return packageByDirectory;
        });
    }
    identifyInstallTargets(packages) {
        const installTargets = Object.keys(this.sourcesByTarget).map(target => ({
            directory: target,
            packageJson: packages[target],
            sources: this.sourcesByTarget[target].map(source => ({
                directory: source,
                packageJson: packages[source]
            }))
        }));
        this.emit('install_targets_identified', installTargets);
        return installTargets;
    }
    packAll() {
        const allSources = _.uniq(_.flatMap(Object.keys(this.sourcesByTarget), target => this.sourcesByTarget[target]));
        this.emit('packing_start', allSources);
        return Promise.all(allSources.map(source => this.packOne(source)))
            .then(() => this.emit('packing_end'));
    }
    packOne(directory) {
        return child_process_1.exec(`npm pack ${quotify(directory)}`, { cwd: this.uniqueDir, maxBuffer: TEN_MEGA_BYTE })
            .then(() => void this.emit('packed', directory));
    }
    removeTmpDirectory() {
        utils_1.del(this.uniqueDir);
    }
}
exports.LocalInstaller = LocalInstaller;
function resolvePackFile(dir, pkg) {
    // Don't forget about scoped packages
    const scopeIndex = pkg.name.indexOf('@');
    const slashIndex = pkg.name.indexOf('/');
    if (scopeIndex === 0 && slashIndex > 0) {
        // @s/b -> s-b-x.x.x.tgz
        return path_1.default.resolve(dir, `${pkg.name.substr(1, slashIndex - 1)}-${pkg.name.substr(slashIndex + 1)}-${pkg.version}.tgz`);
    }
    else {
        // b -> b-x.x.x.tgz
        return path_1.default.resolve(dir, `${pkg.name}-${pkg.version}.tgz`);
    }
}
function resolve(packagesByTarget) {
    const resolvedPackages = {};
    Object.keys(packagesByTarget).forEach(localTarget => {
        resolvedPackages[path_1.default.resolve(localTarget)] = _.uniq(packagesByTarget[localTarget].map(pkg => path_1.default.resolve(pkg)));
    });
    return resolvedPackages;
}
exports.resolve = resolve;
//# sourceMappingURL=LocalInstaller.js.map